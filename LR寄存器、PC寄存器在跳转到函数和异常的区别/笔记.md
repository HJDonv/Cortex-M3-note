最近在看ucosII基于Cortex-M3的源码。遇到了一些疑问，然后上网查了下资料，做了些实验，有了一些体会，写下来用作以后复习。

---

抛出问题：函数返回的BX LR和异常（中断）返回BX LR指令都有什么区别？？

几个容易混淆的问题：  


- 调用函数时候寄存器不一定会入栈，可是异常中断进入中断服务函数寄存器一定会入栈。
- 调用函数时候的LR和中断服务函数的LR有不同的意义。
- 离开普通函数和异常中断函数时候BX LR的导致的行为不一样。  

实验：  
	
	void bb()
	{}
	void aa()
	{
    	bb();
	}
                              
	int main(void)
	{	
		bb();
    	aa();
    	Test(); 
    	while( 1 );
	}

	下面的是汇编，通过软件触发PSV中断。
	Test PROC

    CPSID   I
    
    LDR     R0, =NVIC_SYSPRI14                                  
    LDR     R1, =NVIC_PENDSV_PRI
    STRB    R1, [R0]
    
    LDR     R0, =NVIC_INT_CTRL                                  
    LDR     R1, =NVIC_PENDSVSET
    STR     R1, [R0]
    
    CPSIE   I 
    
    B   .

通过KEIL5仿真该段函数，并且观察寄存器和堆栈的变化。

----

![图1](1.png)

即将进入第一个bb（）函数时候如上图所示。

![图2](2.png)

当进入了第一个bb（）函数时候，LR寄存器为0x0800033D，这个时候的LR寄存器保存的是跨过bb（）函数之后第一条指令的地址，也就是跳转到aa()的指令地址，为什么不是0x800033C呢，M3权威手册有这么一段话：
>如果向 PC 中写数据，就会引起一次程序的分支（ 但是不更新 LR 寄存器）。 CM3 中的指
令至少是半字对齐的，所以 PC 的 LSB 总是读回 0。然而， 在分支时，无论是直接写 PC 的值
还是使用分支指令，都必须保证加载到 PC 的数值是奇数（即 LSB=1） ，用以表明这是在
Thumb 状态下执行。倘若写了 0，则视为企图转入 ARM 模式，CM3 将产生一个 fault 异
常。

也就是说，为了防止在函数返回时候执行BX LR时候，会将LSB为0写进PC寄存器，所以LR寄存器会被改为原指令地址+1，其实执行的都是同一条指令。同时可以发现，这时候的堆栈是干净的，也就是这个调用过程没有对寄存器进行压栈。

![图3](3.png)

当执行BX LR指令退出bb（）之后，就会刷新PC寄存器。

![图4](4.png)

进入aa（）函数之后，情况和第一次进入bb（）函数一样，并没有进行压栈操作。不过，从汇编中可以看到，即将会进行一次压栈操作，并调用bb（）函数。如果不这样进行压栈操作，那么进入bb（）函数之后改变了lr寄存器，就会导致无法从aa（）函数返回到main（）函数，导致程序跑飞，不过这个压栈的过程，是编译器帮我们实现的，对于MCU来说，整个函数调用过程都没有主动压栈过。

![图5](5.png)

执行了压栈指令之后，我们可以从memory看到，Test（）的指令地址被保存进栈了，这个指令地址就是跨过aa（）函数的第一条指令地址。同时R13寄存器也被改变了。

![图6](6.png)
![图7](7.png)

执行了跳转指令和BX LR指令，堆栈没有动过，没有什么特别变化，直到出栈指令。

![图8](8.png)

出栈指令执行之后，R13改变为0X20000400，同时栈里面的0x80000341会POP到PC寄存器上，这就是一个常见的小技巧，将保存的LR寄存器内容直接弹到PC里面去。

至此，通过8张图说明了，普通调用普通函数时候LR寄存器和PC寄存器的变化。

